// Real-time service database schema
// Updated: 2026-01-20 - Added segment and expo models

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum IncidentType {
  HARASSMENT
  MEDICAL
  TECHNICAL
  SECURITY
  ACCESSIBILITY
}

enum IncidentStatus {
  REPORTED
  ACKNOWLEDGED
  INVESTIGATING
  RESOLVED
}

enum IncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

// Add this new enum
enum PointReason {
  MESSAGE_SENT
  MESSAGE_REACTED
  QUESTION_ASKED
  QUESTION_UPVOTED
  POLL_CREATED
  POLL_VOTED
  WAITLIST_JOINED
  TEAM_CREATED
  TEAM_JOINED
  SESSION_JOINED
  CHALLENGE_COMPLETED
  CHALLENGE_WON_FIRST
  CHALLENGE_WON_SECOND
  CHALLENGE_WON_THIRD
  TRIVIA_CORRECT
  TRIVIA_SPEED_BONUS
  TEAM_SYNERGY_BONUS
}

enum ChallengeStatus {
  PENDING
  ACTIVE
  COMPLETED
  CANCELLED
}

enum ChallengeType {
  CHAT_BLITZ
  POLL_RUSH
  QA_SPRINT
  POINTS_RACE
  MULTI_ACTION
  CUSTOM
}

enum TriviaGameStatus {
  DRAFT
  ACTIVE
  COMPLETED
}

enum TriviaQuestionStatus {
  PENDING
  ACTIVE
  REVEALED
}

// Connection tracking enums
enum ConnectionType {
  PROXIMITY_PING
  DM_INITIATED
  SESSION_QA
  MANUAL_EXCHANGE
}

enum OutcomeType {
  MEETING_HELD
  JOB_REFERRAL
  PARTNERSHIP
  SALE_DEAL
  MENTORSHIP
  OTHER
}

enum ContextType {
  SHARED_SESSION
  SHARED_INTEREST
  MUTUAL_CONNECTION
  SAME_COMPANY_SIZE
  SAME_INDUSTRY
  QA_INTERACTION
}

// Connection strength for relationship quality tracking
enum ConnectionStrength {
  WEAK          // Single interaction only
  MODERATE      // Multiple interactions OR follow-up exchanged
  STRONG        // Multiple follow-ups, meeting scheduled, or outcome reported
}

// Activity types for connection activity tracking
enum ConnectionActivityType {
  INITIAL_CONNECT   // First connection made
  DM_SENT           // Direct message sent
  DM_RECEIVED       // Direct message received
  HUDDLE_TOGETHER   // Attended same huddle
  FOLLOW_UP_SENT    // Post-event follow-up sent
  FOLLOW_UP_OPENED  // Follow-up was opened
  FOLLOW_UP_REPLIED // Follow-up was replied to
  MEETING_SCHEDULED // Meeting was scheduled
  MEETING_HELD      // Meeting actually happened
  OUTCOME_REPORTED  // Business outcome reported
  LINKEDIN_CONNECTED // Connected on LinkedIn
}

// Huddle (micro-meetup) enums
enum HuddleStatus {
  FORMING       // Invitations sent, waiting for responses
  CONFIRMED     // Minimum participants reached
  IN_PROGRESS   // Huddle is happening now
  COMPLETED     // Huddle finished successfully
  CANCELLED     // Huddle was cancelled
}

enum HuddleType {
  PROBLEM_BASED   // Based on shared problems/challenges
  SESSION_BASED   // Post-session discussion
  PROXIMITY_BASED // Impromptu based on location
  MANUAL          // User-created
}

enum HuddleParticipantStatus {
  INVITED   // Invitation sent
  ACCEPTED  // User accepted
  DECLINED  // User declined
  ATTENDED  // User actually showed up
  NO_SHOW   // Accepted but didn't attend
}

model SyncLog {
  id        String   @id @default(cuid())
  timestamp DateTime @default(now())

  // The user this change is relevant for
  userId    String
  user      UserReference @relation(fields: [userId], references: [id])
  
  resource  String // e.g., 'MESSAGE', 'POLL'
  action    String // e.g., 'CREATED', 'UPDATED'
  payload   Json   // The actual data payload

  @@index([userId, timestamp])
  @@map("sync_logs")
}

model UserReference {
  id                        String @id
  email                     String @unique
  firstName                 String?
  lastName                  String?
  avatarUrl                 String?

  // LinkedIn integration fields
  linkedInUrl               String?
  linkedInId                String?
  linkedInHeadline          String?
  linkedInAccessToken       String?
  linkedInRefreshToken      String?
  linkedInTokenExpiresAt    DateTime?

  // Relations
  profile                   UserProfile?
  messages                  Message[]
  questions                 Question[]
  questionUpvotes           QuestionUpvote[]
  createdPolls              Poll[]
  pollVotes                 PollVote[]
  // This now correctly points to the Conversation model
  conversations             Conversation[]
  sentDirectMessages        DirectMessage[]  @relation("SentMessages")
  reportedIncidents         Incident[]
  assignedIncidents         Incident[] @relation("AssignedIncidents")
  syncLogs                  SyncLog[]
  answers                   Answer[]
  messageReactions          MessageReaction[]
  gamificationPointEntries  GamificationPointEntry[]
  gamificationAchievements  GamificationAchievement[]
  createdCircles            ConversationCircle[]
  circleMemberships         ConversationCircleParticipant[]
  sentBackchannelMessages   BackchannelMessage[]
  createdTeams              Team[]
  teamMemberships           TeamMembership[]
  teamMessages              TeamMessage[]
  createdChallenges         TeamChallenge[]
  createdTriviaGames        TriviaGame[]
  triviaAnswers             TriviaAnswer[]
  contentDrops              ContentDropLog[]
  connectionsAsUserA        Connection[] @relation("ConnectionUserA")
  connectionsAsUserB        Connection[] @relation("ConnectionUserB")

  // Breakout rooms
  createdBreakoutRooms      BreakoutRoom[]        @relation("BreakoutRoomCreator")
  facilitatedBreakoutRooms  BreakoutRoom[]        @relation("BreakoutRoomFacilitator")
  breakoutParticipations    BreakoutParticipant[]

  // Segment-based assignment
  createdSegments           BreakoutSegment[]
  segmentMemberships        BreakoutSegmentMember[]
  roomAssignments           BreakoutRoomAssignment[]

  @@map("user_references")
}

model Conversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // This now correctly points to the UserReference model
  participants UserReference[]
  messages     DirectMessage[]

  @@map("conversations")
}

// NOTE: The incorrect '_ConversationParticipants' model has been completely removed.
// Prisma will now generate the required join table in the background.

model ChatSession {
  id                          String @id @default(cuid())
  name                        String
  createdAt                   DateTime @default(now())
  updatedAt                   DateTime @updatedAt
  participants                String[]
  eventId                     String
  organizationId              String
  messages                    Message[]
  questions                   Question[]
  polls                       Poll[]
  presentation                Presentation? // Add the one-to-one relation
  incidents                   Incident[]
  gamificationPointEntries    GamificationPointEntry[]
  conversationCircles         ConversationCircle[]
  backchannelMessages         BackchannelMessage[]
  teams                       Team[]
  contentDrops                ContentDropLog[]
  giveawayWinners             GiveawayWinner[]
  quizSettings                SessionQuizSettings?
  teamChallenges              TeamChallenge[]
  triviaGames                 TriviaGame[]
  @@map("chat_sessions")
}

// Add the new Incident model
model Incident {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  type      IncidentType
  severity  IncidentSeverity
  status    IncidentStatus @default(REPORTED)
  details   String         @db.Text

  reporterId String
  reporter   UserReference @relation(fields: [reporterId], references: [id])
  
  // To associate with the event and org
  organizationId String
  eventId        String
  sessionId      String
  session        ChatSession   @relation(fields: [sessionId], references: [id])

  // To track which admin is handling the incident
  assigneeId String?
  assignee   UserReference? @relation("AssignedIncidents", fields: [assigneeId], references: [id])

  resolutionNotes String?

  @@map("incidents")
}

//client keeps asking server for updates every 5 seconds: feature to be worked on

model Message {
  id        String   @id @default(cuid())
  text      String
  timestamp DateTime @default(now())
  metadata  Json?
  authorId  String
  author    UserReference @relation(fields: [authorId], references: [id], onDelete: Cascade)
  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  // --- ADD THESE FIELDS FOR THREADING ---
  replyingToMessageId String?
  parentMessage       Message?  @relation("Replies", fields: [replyingToMessageId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies             Message[] @relation("Replies")
  // --- END OF NEW FIELDS ---
  reactions MessageReaction[]
   
  @@index([sessionId, timestamp])
  @@map("messages")
}

model DirectMessage {
  id             String   @id @default(cuid())
  text           String   @db.Text
  timestamp      DateTime @default(now())
  isDelivered    Boolean  @default(false)
  deliveredAt    DateTime?
  isRead         Boolean  @default(false)
  readAt         DateTime?
  isEdited       Boolean  @default(false) 
  editedAt       DateTime?  
  metadata      Json?      @default("{}")  
  senderId       String
  sender         UserReference @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  conversationId String
  conversation   Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  @@map("direct_messages")
}

model Answer {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  text      String   @db.Text

  authorId String
  author   UserReference @relation(fields: [authorId], references: [id], onDelete: Cascade)

  questionId String    @unique // Enforces a one-to-one relationship
  question   Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@map("answers")
}

model Question {
  id          String   @id @default(cuid())
  text        String   @db.VarChar(500)
  isAnonymous Boolean  @default(false)
  status      String   @default("pending")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  authorId    String
  author      UserReference @relation(fields: [authorId], references: [id], onDelete: Cascade)
  sessionId   String
  session     ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  isAnswered  Boolean  @default(false)
  upvotes     QuestionUpvote[]
  answer      Answer?
    
  tags        String[]
  @@map("questions")
}

model QuestionUpvote {
  userId     String
  user       UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  questionId String
  question   Question      @relation(fields: [questionId], references: [id], onDelete: Cascade)
  createdAt  DateTime      @default(now())
  @@id([userId, questionId])
  @@map("question_upvotes")
}

// Add this new model
model MessageReaction {
  id        String   @id @default(cuid())
  emoji     String
  createdAt DateTime @default(now())

  userId    String
  user      UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  messageId String
  message   Message       @relation(fields: [messageId], references: [id], onDelete: Cascade)

  // Enforces that a user can only react with the same emoji once per message
  @@unique([userId, messageId, emoji])
  @@map("message_reactions")
}

model Poll {
  id              String   @id @default(cuid())
  question        String
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  expiresAt       DateTime?
  creatorId       String
  creator         UserReference @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  sessionId       String
  session         ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  options         PollOption[]
  votes           PollVote[]
  giveawayWinners GiveawayWinner[]

  // Quiz/Giveaway fields
  correctOptionId String?     // For quiz mode - the correct answer
  isQuiz          Boolean  @default(false)  // Whether this poll is part of a quiz
  giveawayEnabled Boolean  @default(false)  // Whether giveaway can be run on this poll

  @@map("polls")
}

model PollOption {
  id     String     @id @default(cuid())
  text   String
  pollId String
  poll   Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  votes  PollVote[]
  @@map("poll_options")
}

model PollVote {
  userId   String
  user     UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  pollId   String
  poll     Poll          @relation(fields: [pollId], references: [id], onDelete: Cascade)
  optionId String
  option   PollOption    @relation(fields: [optionId], references: [id], onDelete: Cascade)
  createdAt DateTime   @default(now())
  @@id([userId, pollId])
  @@map("poll_votes")
}

enum GiveawayType {
  SINGLE_POLL
  QUIZ_SCORE
}

enum ClaimStatus {
  PENDING
  CLAIMED
  EXPIRED
}

model GiveawayWinner {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Context
  sessionId String
  session   ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  eventId   String
  pollId    String?     // NULL for quiz giveaways
  poll      Poll?       @relation(fields: [pollId], references: [id], onDelete: SetNull)

  // Winner Identity
  userId      String
  winnerName  String
  winnerEmail String

  // Giveaway Details
  giveawayType      GiveawayType
  winningOptionText String?       // For single poll
  quizScore         Int?          // For quiz (e.g., 4 out of 5)
  quizTotal         Int?          // Total quiz questions

  // Prize Details
  prizeTitle       String?
  prizeDescription String?
  prizeType        String?       // 'physical' | 'virtual' | 'voucher'
  prizeValue       Decimal?      @db.Decimal(10, 2)

  // Claim Information
  claimInstructions String?
  claimLocation     String?       // For physical prizes
  claimDeadline     DateTime?
  claimedAt         DateTime?
  claimStatus       ClaimStatus   @default(PENDING)

  // Notification Status
  emailSent     Boolean   @default(false)
  emailSentAt   DateTime?
  notificationError String?

  // Who ran the giveaway
  createdById   String?

  @@index([sessionId])
  @@index([eventId])
  @@index([userId])
  @@map("giveaway_winners")
}

model SessionQuizSettings {
  id        String   @id @default(cuid())
  sessionId String   @unique
  session   ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Quiz Configuration
  quizEnabled    Boolean @default(false)
  passingScore   Int     @default(3)      // Minimum correct answers to win
  totalQuestions Int?                      // Auto-calculated from polls

  // Prize Configuration
  prizeTitle         String?
  prizeDescription   String?
  prizeType          String?   @default("virtual")
  prizeValue         Decimal?  @db.Decimal(10, 2)
  claimInstructions  String?
  claimLocation      String?
  claimDeadlineHours Int       @default(72)  // Hours after giveaway to claim

  // Limits
  maxWinners Int?                          // NULL = unlimited

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("session_quiz_settings")
}

model Presentation {
  id        String   @id @default(cuid())
  sessionId String   @unique // Each session has one presentation
  session   ChatSession @relation(fields: [sessionId], references: [id])
  
  // This will store the ordered list of URLs from S3/CDN
  slideUrls String[]

  @@map("presentations")
}

model GamificationPointEntry {
  id          String     @id @default(cuid())
  createdAt   DateTime   @default(now())
  points      Int
  actionCount Int        @default(0)
  reason      PointReason

  userId    String
  user      UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)

  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([userId, sessionId, reason])
  @@index([userId, sessionId])
  @@map("gamification_point_entries")
}

model GamificationAchievement {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  badgeName   String   // e.g., "First Question", "Super Voter"
  description String

  userId      String
  user        UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeName])
  @@map("gamification_achievements")
}

model ConversationCircle {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  topic     String   @db.VarChar(255)
  isActive  Boolean  @default(true)

  creatorId String
  creator   UserReference @relation(fields: [creatorId], references: [id])
  
  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id])
  
  participants ConversationCircleParticipant[]

  @@map("conversation_circles")
}


model ConversationCircleParticipant {
  joinedAt DateTime @default(now())

  userId   String
  user     UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  circleId String
  circle   ConversationCircle @relation(fields: [circleId], references: [id], onDelete: Cascade)
  
  @@id([userId, circleId])
  @@map("conversation_circle_participants")
}

model BackchannelMessage {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  text      String   @db.Text

  senderId  String
  sender    UserReference @relation(fields: [senderId], references: [id], onDelete: Cascade)

  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@map("backchannel_messages")
}

// Add these new models
model Team {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  name      String

  creatorId String
  creator   UserReference @relation(fields: [creatorId], references: [id])
  
  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id])
  
  members            TeamMembership[]
  challengeProgress  TeamChallengeProgress[]
  messages           TeamMessage[]
  triviaAnswers      TriviaAnswer[]
  triviaScores       TriviaTeamScore[]

  @@unique([sessionId, name])
  @@index([sessionId])
  @@index([creatorId])
  @@map("teams")
}

model TeamMembership {
  joinedAt DateTime @default(now())

  userId String
  user   UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)

  teamId String
  team   Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@id([userId, teamId])
  @@index([teamId])
  @@map("team_memberships")
}

// Add this new model
model ContentDropLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  dropperId String
  dropper   UserReference @relation(fields: [dropperId], references: [id])

  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id])

  title       String
  description String?
  contentType String // e.g., 'DOCUMENT', 'LINK'
  contentUrl  String

  @@map("content_drop_logs")
}

// Connection tracking models for networking feature
model Connection {
  id            String    @id @default(cuid())
  userAId       String
  userBId       String
  eventId       String

  // Connection metadata
  connectedAt   DateTime  @default(now())
  connectionType ConnectionType @default(PROXIMITY_PING)
  initialMessage String?

  // Connection strength (calculated based on activities)
  strength      ConnectionStrength @default(WEAK)
  lastInteractionAt DateTime?
  interactionCount  Int @default(1)

  // Follow-up tracking
  followUpSentAt    DateTime?
  followUpOpenedAt  DateTime?
  followUpRepliedAt DateTime?
  followUpMessage   String?  @db.Text  // AI-generated follow-up suggestion

  // Outcome tracking
  meetingScheduled  Boolean @default(false)
  meetingDate       DateTime?
  outcomeType       OutcomeType?
  outcomeNotes      String?
  outcomeReportedAt DateTime?

  // Relations
  userA         UserReference @relation("ConnectionUserA", fields: [userAId], references: [id])
  userB         UserReference @relation("ConnectionUserB", fields: [userBId], references: [id])
  contexts      ConnectionContext[]
  activities    ConnectionActivity[]

  @@unique([userAId, userBId, eventId])
  @@index([userAId])
  @@index([userBId])
  @@index([eventId])
  @@index([strength])
  @@map("connections")
}

model ConnectionContext {
  id            String   @id @default(cuid())
  connectionId  String
  contextType   ContextType
  contextValue  String

  connection    Connection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@index([connectionId])
  @@map("connection_contexts")
}

// Activity log for connection interactions
model ConnectionActivity {
  id            String   @id @default(cuid())
  connectionId  String
  createdAt     DateTime @default(now())

  // Activity details
  activityType  ConnectionActivityType
  description   String?  @db.Text
  metadata      Json?    // Additional context (e.g., message ID, huddle ID)

  // Who initiated this activity (optional, for directional activities)
  initiatorId   String?

  connection    Connection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@index([connectionId])
  @@index([createdAt])
  @@index([activityType])
  @@map("connection_activities")
}

// Huddle (micro-meetup) models for facilitated networking
model Huddle {
  id               String       @id @default(cuid())
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  // Huddle details
  topic            String       @db.VarChar(100)
  problemStatement String?      @db.Text
  description      String?      @db.Text

  // Event context
  eventId          String
  sessionId        String?      // Optional: if huddle is post-session

  // Location and timing
  locationName     String?      @db.VarChar(255)
  locationDetails  String?      @db.Text  // Room number, directions, etc.
  scheduledAt      DateTime
  duration         Int          @default(15)  // Duration in minutes

  // Status and type
  status           HuddleStatus @default(FORMING)
  huddleType       HuddleType   @default(PROBLEM_BASED)

  // Participant limits
  minParticipants  Int          @default(2)
  maxParticipants  Int          @default(6)

  // Optimistic locking for race condition handling
  version          Int          @default(1)

  // Creator (the system or user who initiated)
  createdById      String?

  // Relations
  participants     HuddleParticipant[]

  @@index([eventId])
  @@index([status])
  @@index([scheduledAt])
  @@map("huddles")
}

model HuddleParticipant {
  id          String   @id @default(cuid())
  huddleId    String
  userId      String

  // Status tracking
  status      HuddleParticipantStatus @default(INVITED)
  invitedAt   DateTime @default(now())
  respondedAt DateTime?
  attendedAt  DateTime?

  // Match score (why this user was invited)
  matchScore  Float?
  matchReason String?  @db.Text  // JSON or text explaining why they were matched

  // Relation
  huddle      Huddle   @relation(fields: [huddleId], references: [id], onDelete: Cascade)

  @@unique([huddleId, userId])
  @@index([userId])
  @@index([huddleId, status])
  @@map("huddle_participants")
}

// ==========================
// AI Matchmaking Models
// ==========================

// User networking profile for AI matchmaking
model UserProfile {
  id                String   @id @default(cuid())
  userId            String   @unique
  user              UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)

  // From registration (required)
  interests         String[]
  goals             Goal[]

  // From registration (optional)
  bio               String?  @db.Text
  currentRole       String?  // Job title/role for segmentation
  company           String?  // Company name for segmentation
  industry          String?
  companySize       CompanySize?
  yearsExperience   Int?
  experienceLevel   String?  // junior, mid, senior, executive
  skillsToOffer     String[]
  skillsNeeded      String[]

  // From enrichment agent (auto-populated)
  enrichmentStatus  EnrichmentStatus @default(PENDING)
  enrichedAt        DateTime?

  // Professional platforms
  linkedInHeadline  String?
  linkedInUrl       String?
  githubUsername    String?
  githubTopLanguages String[]
  githubRepoCount   Int?
  twitterHandle     String?
  twitterBio        String?

  // Content/Social platforms
  youtubeChannelUrl String?
  youtubeChannelName String?
  youtubeSubscriberRange String?
  instagramHandle   String?
  instagramBio      String?
  facebookProfileUrl String?

  // General
  personalWebsite   String?
  extractedSkills   String[]
  extractedInterests String[]
  enrichmentSources String[]

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([userId])
  @@map("user_profiles")
}

// AI-generated matchmaking recommendations
model Recommendation {
  id                  String   @id @default(cuid())
  userId              String
  eventId             String
  recommendedUserId   String

  // LLM-generated content
  matchScore          Int      // 0-100
  reasons             String[]
  conversationStarters String[]
  potentialValue      String?

  // Metadata
  generatedAt         DateTime @default(now())
  expiresAt           DateTime

  // Tracking
  viewed              Boolean  @default(false)
  viewedAt            DateTime?
  pinged              Boolean  @default(false)
  pingedAt            DateTime?
  connected           Boolean  @default(false)
  connectedAt         DateTime?

  @@unique([userId, eventId, recommendedUserId])
  @@index([userId, eventId])
  @@index([eventId, expiresAt])
  @@map("recommendations")
}

// Feedback on connections for ML learning
model ConnectionFeedback {
  id              String   @id @default(cuid())
  connectionId    String
  userId          String   // Who is giving feedback

  // Rating
  rating          Int      // 1-5 stars

  // Qualitative
  wasValuable     Boolean?
  willFollowUp    Boolean?
  wouldRecommend  Boolean?

  // What made it good/bad
  positiveFactors String[]
  negativeFactors String[]

  // Free text
  comments        String?  @db.Text

  createdAt       DateTime @default(now())

  @@unique([connectionId, userId])
  @@index([connectionId])
  @@map("connection_feedback")
}

// Feedback on specific recommendations
model RecommendationFeedback {
  id                String   @id @default(cuid())
  recommendationId  String
  userId            String

  // Did they act on it?
  action            RecommendationAction

  // If they connected, how was it?
  connectionRating  Int?     // 1-5

  // Why did they skip?
  skipReason        String?

  createdAt         DateTime @default(now())

  @@unique([recommendationId, userId])
  @@index([recommendationId])
  @@map("recommendation_feedback")
}

enum Goal {
  LEARN
  NETWORK
  HIRE
  GET_HIRED
  FIND_PARTNERS
  FIND_INVESTORS
  SELL
  BUY
  MENTOR
  GET_MENTORED
}

enum CompanySize {
  SOLO
  STARTUP_1_10
  SMALL_11_50
  MEDIUM_51_200
  LARGE_201_1000
  ENTERPRISE_1000_PLUS
}

enum EnrichmentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  OPTED_OUT
}

enum RecommendationAction {
  VIEWED
  PINGED
  MESSAGED
  CONNECTED
  SKIPPED
  IGNORED
}

// ==========================
// Breakout Room Enums
// ==========================

enum BreakoutRoomStatus {
  WAITING    // Room created, waiting to start
  ACTIVE     // Room is live
  CLOSING    // Warning sent, about to close
  CLOSED     // Room ended
}

enum BreakoutParticipantRole {
  FACILITATOR
  PARTICIPANT
}

// ==========================
// Breakout Room Models
// ==========================

model BreakoutRoom {
  id                String              @id @default(cuid())
  createdAt         DateTime            @default(now())

  sessionId         String              // Parent session ID (from event-lifecycle-service)
  eventId           String              // Event ID for easier querying

  name              String              @db.VarChar(100)
  topic             String?             @db.VarChar(500)
  maxParticipants   Int                 @default(8)
  durationMinutes   Int                 @default(15)
  autoAssign        Boolean             @default(false)

  status            BreakoutRoomStatus  @default(WAITING)
  startedAt         DateTime?
  endedAt           DateTime?

  creatorId         String
  creator           UserReference       @relation("BreakoutRoomCreator", fields: [creatorId], references: [id])

  facilitatorId     String?
  facilitator       UserReference?      @relation("BreakoutRoomFacilitator", fields: [facilitatorId], references: [id])

  participants      BreakoutParticipant[]

  // Video room integration (external provider like Daily.co, Twilio, etc.)
  videoRoomId       String?             @db.VarChar(255)
  videoRoomUrl      String?             @db.VarChar(500)

  // Segment-based assignment relations
  segmentRules      BreakoutSegmentRule[]
  assignments       BreakoutRoomAssignment[]

  @@index([sessionId])
  @@index([eventId])
  @@index([status])
  @@index([createdAt])           // For analytics queries
  @@index([startedAt])           // For active room queries
  @@map("breakout_rooms")
}

model BreakoutParticipant {
  id                    String                    @id @default(cuid())
  joinedAt              DateTime                  @default(now())
  leftAt                DateTime?

  role                  BreakoutParticipantRole   @default(PARTICIPANT)
  speakingTimeSeconds   Int                       @default(0)

  userId                String
  user                  UserReference             @relation(fields: [userId], references: [id], onDelete: Cascade)

  roomId                String
  room                  BreakoutRoom              @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@unique([userId, roomId])
  @@index([roomId])
  @@map("breakout_participants")
}

// ==========================
// Segment-Based Room Assignment
// ==========================

// Defines segments for organizing attendees (e.g., "Developers", "Marketing", "Enterprise")
model BreakoutSegment {
  id                String              @id @default(cuid())
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  sessionId         String              // Parent session for these segments
  eventId           String              // Event ID for easier querying

  name              String              @db.VarChar(100)  // e.g., "Developers", "Marketing"
  description       String?             @db.VarChar(500)
  color             String?             @db.VarChar(7)    // Hex color for UI display

  // Field-based segmentation from registration data
  // e.g., { "field": "jobRole", "operator": "equals", "value": "Developer" }
  matchCriteria     Json?

  // Priority for assignment when user matches multiple segments (lower = higher priority)
  priority          Int                 @default(0)

  creatorId         String
  creator           UserReference       @relation(fields: [creatorId], references: [id])

  // Relations
  assignmentRules   BreakoutSegmentRule[]
  members           BreakoutSegmentMember[]

  @@index([sessionId])
  @@index([eventId])
  @@map("breakout_segments")
}

// Members of a segment (can be auto-assigned via criteria or manually added)
model BreakoutSegmentMember {
  id                String              @id @default(cuid())
  createdAt         DateTime            @default(now())

  segmentId         String
  segment           BreakoutSegment     @relation(fields: [segmentId], references: [id], onDelete: Cascade)

  userId            String
  user              UserReference       @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Whether this was auto-assigned (from criteria) or manually added
  isAutoAssigned    Boolean             @default(true)

  @@unique([segmentId, userId])
  @@index([userId])
  @@map("breakout_segment_members")
}

// Rules that assign segments to specific breakout rooms
model BreakoutSegmentRule {
  id                String              @id @default(cuid())
  createdAt         DateTime            @default(now())

  segmentId         String
  segment           BreakoutSegment     @relation(fields: [segmentId], references: [id], onDelete: Cascade)

  roomId            String
  room              BreakoutRoom        @relation(fields: [roomId], references: [id], onDelete: Cascade)

  // Assignment configuration
  maxFromSegment    Int?                // Max attendees from this segment (null = unlimited up to room capacity)

  @@unique([segmentId, roomId])  // One rule per segment-room pair
  @@index([roomId])
  @@map("breakout_segment_rules")
}

// Pre-computed room assignments for attendees (shown before session starts)
model BreakoutRoomAssignment {
  id                String              @id @default(cuid())
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  sessionId         String              // Session these assignments are for
  eventId           String

  userId            String
  user              UserReference       @relation(fields: [userId], references: [id], onDelete: Cascade)

  roomId            String
  room              BreakoutRoom        @relation(fields: [roomId], references: [id], onDelete: Cascade)

  // Which segment rule triggered this assignment (for transparency)
  segmentId         String?

  // Status of the assignment
  status            AssignmentStatus    @default(PENDING)
  notifiedAt        DateTime?           // When user was notified of assignment

  @@unique([sessionId, userId])  // One assignment per user per session
  @@index([sessionId])
  @@index([roomId])
  @@index([userId])
  @@index([status])              // For filtering by assignment status
  @@index([createdAt])           // For analytics queries on date ranges
  @@index([segmentId])           // For segment-based queries
  @@map("breakout_room_assignments")
}

enum AssignmentStatus {
  PENDING     // Assignment created but not yet shown to user
  NOTIFIED    // User has been notified of their assignment
  CONFIRMED   // User has acknowledged/seen the assignment
  JOINED      // User has joined their assigned room
  DECLINED    // User declined or was reassigned
}

// ==========================
// Virtual Expo Hall Enums
// ==========================

enum ExpoHallLayout {
  GRID        // Traditional grid layout of booth cards
  FLOOR_PLAN  // Visual floor plan with positioned booths
  LIST        // List view with details
}

enum BoothTier {
  PLATINUM
  GOLD
  SILVER
  BRONZE
  STARTUP
}

enum BoothVisitorStatus {
  BROWSING      // Viewing booth details
  IN_CHAT       // Active in booth chat
  IN_VIDEO      // In video call with staff
}

enum BoothVideoSessionStatus {
  REQUESTED     // Attendee requested video
  ACCEPTED      // Staff accepted, waiting to connect
  ACTIVE        // Video call in progress
  COMPLETED     // Call ended normally
  DECLINED      // Staff declined request
  CANCELLED     // Attendee cancelled request
  EXPIRED       // Request timed out
}

enum StaffPresenceStatus {
  ONLINE        // Available for interactions
  AWAY          // Temporarily unavailable
  BUSY          // In video call or handling multiple chats
  OFFLINE       // Not currently at booth
}

enum BoothQueueStatus {
  WAITING       // In queue, waiting to enter
  ADMITTED      // Notified to enter (60s window)
  ENTERED       // Successfully entered after being admitted
  LEFT          // Left the queue voluntarily
  EXPIRED       // Admission notification expired
}

// ==========================
// Virtual Expo Hall Models
// ==========================

model ExpoHall {
  id                String          @id @default(cuid())
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  eventId           String          // From event-lifecycle-service
  organizationId    String

  name              String          @db.VarChar(200)
  description       String?         @db.Text
  layout            ExpoHallLayout  @default(GRID)
  categories        String[]        // e.g., ["Technology", "Services", "Startups"]

  // Availability window
  opensAt           DateTime?
  closesAt          DateTime?
  isActive          Boolean         @default(true)

  // Customization
  bannerUrl         String?         @db.VarChar(500)
  welcomeMessage    String?         @db.Text

  // Relations
  booths            ExpoBooth[]

  @@unique([eventId])               // One expo hall per event
  @@index([eventId])
  @@index([isActive])
  @@map("expo_halls")
}

model ExpoBooth {
  id                String          @id @default(cuid())
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  expoHallId        String
  expoHall          ExpoHall        @relation(fields: [expoHallId], references: [id], onDelete: Cascade)

  sponsorId         String          // FK to sponsor in event-lifecycle-service
  organizationId    String          // Sponsor's organization

  // Booth identity
  boothNumber       String          @db.VarChar(20)
  tier              BoothTier       @default(BRONZE)
  name              String          @db.VarChar(200)
  tagline           String?         @db.VarChar(300)
  description       String?         @db.Text

  // Media assets
  logoUrl           String?         @db.VarChar(500)
  bannerUrl         String?         @db.VarChar(500)
  videoUrl          String?         @db.VarChar(500)   // Booth video loop

  // Resources - stored as JSONB
  // Format: [{ id, title, type, url, description, downloadCount }]
  resources         Json            @default("[]")

  // Call-to-action buttons - stored as JSONB
  // Format: [{ id, label, url, style, icon, clickCount }]
  ctaButtons        Json            @default("[]")

  // Staff management - user IDs from event-lifecycle-service
  staffIds          String[]

  // Features
  chatEnabled       Boolean         @default(true)
  videoEnabled      Boolean         @default(true)

  // Visitor capacity (null = unlimited)
  maxVisitors       Int?

  // Floor plan positioning (for FLOOR_PLAN layout)
  positionX         Int?
  positionY         Int?
  width             Int?
  height            Int?

  // Category for filtering
  category          String?         @db.VarChar(100)

  // Sorting within tier
  displayOrder      Int             @default(0)

  // Relations
  visits            BoothVisit[]
  chatMessages      BoothChatMessage[]
  videoSessions     BoothVideoSession[]
  staffPresence     BoothStaffPresence[]
  queueEntries      BoothQueueEntry[]

  @@unique([expoHallId, boothNumber])
  @@index([expoHallId])
  @@index([sponsorId])
  @@index([tier])
  @@index([category])
  @@map("expo_booths")
}

model BoothVisit {
  id                String              @id @default(cuid())
  enteredAt         DateTime            @default(now())
  exitedAt          DateTime?

  boothId           String
  booth             ExpoBooth           @relation(fields: [boothId], references: [id], onDelete: Cascade)

  userId            String
  eventId           String              // Denormalized for easier querying

  // Visit tracking
  status            BoothVisitorStatus  @default(BROWSING)
  durationSeconds   Int                 @default(0)

  // Engagement tracking - stored as JSONB
  // Format: [{ action, timestamp, metadata }]
  // Actions: "resource_download", "cta_click", "video_watch", "chat_message"
  actions           Json                @default("[]")

  // Lead capture
  leadCaptured      Boolean             @default(false)
  leadCapturedAt    DateTime?
  leadData          Json?               // Captured form data

  // Session info for reconnection
  socketId          String?             @db.VarChar(100)

  @@index([boothId])
  @@index([userId])
  @@index([eventId])
  @@index([enteredAt])
  @@index([boothId, userId])            // For checking active visits
  @@map("booth_visits")
}

model BoothQueueEntry {
  id                String            @id @default(cuid())
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  boothId           String
  booth             ExpoBooth         @relation(fields: [boothId], references: [id], onDelete: Cascade)

  userId            String
  userName          String            @db.VarChar(200)
  eventId           String

  // Queue management
  position          Int               // 1-based queue position
  status            BoothQueueStatus  @default(WAITING)

  // Timing
  admittedAt        DateTime?
  enteredAt         DateTime?
  leftAt            DateTime?

  // Socket tracking for notifications
  socketId          String?           @db.VarChar(100)

  @@unique([boothId, userId])         // One queue entry per user per booth
  @@index([boothId, status])          // For finding waiting entries
  @@index([boothId, position])        // For position lookups
  @@index([userId])
  @@map("booth_queue_entries")
}

model BoothChatMessage {
  id                String          @id @default(cuid())
  createdAt         DateTime        @default(now())

  boothId           String
  booth             ExpoBooth       @relation(fields: [boothId], references: [id], onDelete: Cascade)

  senderId          String
  senderName        String          @db.VarChar(200)    // Cached for display
  senderAvatarUrl   String?         @db.VarChar(500)    // Cached for display
  isStaff           Boolean         @default(false)

  // Message content
  text              String          @db.Text
  metadata          Json?           // For rich content (links, mentions)

  // Soft delete for moderation
  isDeleted         Boolean         @default(false)
  deletedAt         DateTime?
  deletedBy         String?

  @@index([boothId])
  @@index([createdAt])
  @@index([senderId])                    // For user activity tracking
  @@index([boothId, createdAt])         // For paginated history
  @@map("booth_chat_messages")
}

model BoothVideoSession {
  id                String                    @id @default(cuid())
  createdAt         DateTime                  @default(now())
  updatedAt         DateTime                  @updatedAt

  boothId           String
  booth             ExpoBooth                 @relation(fields: [boothId], references: [id], onDelete: Cascade)

  // Participants
  attendeeId        String
  attendeeName      String                    @db.VarChar(200)
  staffId           String?
  staffName         String?                   @db.VarChar(200)

  // Session status
  status            BoothVideoSessionStatus   @default(REQUESTED)
  requestedAt       DateTime                  @default(now())
  acceptedAt        DateTime?
  startedAt         DateTime?
  endedAt           DateTime?

  // Duration tracking
  durationSeconds   Int                       @default(0)

  // Daily.co integration
  videoRoomId       String?                   @db.VarChar(255)
  videoRoomUrl      String?                   @db.VarChar(500)
  attendeeToken     String?                   @db.VarChar(1000)
  staffToken        String?                   @db.VarChar(1000)

  // Notes from staff
  staffNotes        String?                   @db.Text

  @@index([boothId])
  @@index([attendeeId])
  @@index([staffId])
  @@index([status])
  @@index([boothId, status])              // For finding pending requests
  @@map("booth_video_sessions")
}

model BoothStaffPresence {
  id                String                @id @default(cuid())
  updatedAt         DateTime              @updatedAt

  boothId           String
  booth             ExpoBooth             @relation(fields: [boothId], references: [id], onDelete: Cascade)

  staffId           String
  staffName         String                @db.VarChar(200)
  staffAvatarUrl    String?               @db.VarChar(500)

  // Presence info
  status            StaffPresenceStatus   @default(OFFLINE)
  lastSeenAt        DateTime              @default(now())

  // Socket tracking
  socketId          String?               @db.VarChar(100)

  @@unique([boothId, staffId])
  @@index([boothId])
  @@index([status])
  @@map("booth_staff_presence")
}

// Analytics aggregation for booth performance
model BoothAnalytics {
  id                String          @id @default(cuid())
  updatedAt         DateTime        @updatedAt

  boothId           String          @unique
  eventId           String

  // Visitor metrics
  totalVisitors     Int             @default(0)
  uniqueVisitors    Int             @default(0)
  currentVisitors   Int             @default(0)
  peakVisitors      Int             @default(0)
  avgVisitDuration  Int             @default(0)   // In seconds

  // Engagement metrics
  totalChatMessages Int             @default(0)
  totalVideoSessions Int            @default(0)
  completedVideoSessions Int        @default(0)
  avgVideoDuration  Int             @default(0)   // In seconds

  // Resource metrics - stored as JSONB
  // Format: { resourceId: downloadCount }
  resourceDownloads Json            @default("{}")
  totalDownloads    Int             @default(0)

  // CTA metrics - stored as JSONB
  // Format: { ctaId: clickCount }
  ctaClicks         Json            @default("{}")
  totalCtaClicks    Int             @default(0)

  // Lead metrics
  totalLeads        Int             @default(0)

  @@index([boothId])
  @@index([eventId])
  @@map("booth_analytics")
}

// ==========================
// Team Challenges & Trivia
// ==========================

model TeamChallenge {
  id               String          @id @default(cuid())
  createdAt        DateTime        @default(now())

  sessionId        String
  session          ChatSession     @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  name             String          @db.VarChar(200)
  description      String?         @db.Text
  type             ChallengeType
  status           ChallengeStatus @default(PENDING)

  durationMinutes  Int             @default(10)
  startedAt        DateTime?
  endedAt          DateTime?

  // Which PointReason actions count toward this challenge (e.g. MESSAGE_SENT for Chat Blitz)
  trackedReason    PointReason?
  // For MULTI_ACTION or CUSTOM: JSON map of { reason: weight } e.g. {"MESSAGE_SENT": 1, "POLL_VOTED": 2}
  actionWeights    Json?

  // Reward points for top 3 teams
  rewardFirst      Int             @default(50)
  rewardSecond     Int             @default(30)
  rewardThird      Int             @default(15)

  createdById      String
  createdBy        UserReference   @relation(fields: [createdById], references: [id])

  progress         TeamChallengeProgress[]

  @@index([sessionId])
  @@index([status])
  @@index([sessionId, status])
  @@map("team_challenges")
}

model TeamChallengeProgress {
  id            String         @id @default(cuid())

  challengeId   String
  challenge     TeamChallenge  @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  teamId        String
  team          Team           @relation(fields: [teamId], references: [id], onDelete: Cascade)

  score         Int            @default(0)
  actionCount   Int            @default(0)
  finalRank     Int?

  @@unique([challengeId, teamId])
  @@index([challengeId])
  @@index([teamId])
  @@map("team_challenge_progress")
}

model TeamMessage {
  id         String        @id @default(cuid())
  createdAt  DateTime      @default(now())

  teamId     String
  team       Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)

  authorId   String
  author     UserReference @relation(fields: [authorId], references: [id], onDelete: Cascade)

  text       String        @db.Text
  metadata   Json?
  reactions  Json?         @default("{}")

  @@index([teamId, createdAt])
  @@map("team_messages")
}

model TriviaGame {
  id                String            @id @default(cuid())
  createdAt         DateTime          @default(now())

  sessionId         String
  session           ChatSession       @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  name              String            @db.VarChar(200)
  status            TriviaGameStatus  @default(DRAFT)

  timePerQuestion   Int               @default(30)  // seconds
  pointsCorrect     Int               @default(10)
  pointsSpeedBonus  Int               @default(5)

  createdById       String
  createdBy         UserReference     @relation(fields: [createdById], references: [id])

  questions         TriviaQuestion[]
  teamScores        TriviaTeamScore[]

  @@index([sessionId])
  @@index([status])
  @@map("trivia_games")
}

model TriviaQuestion {
  id            String               @id @default(cuid())

  gameId        String
  game          TriviaGame           @relation(fields: [gameId], references: [id], onDelete: Cascade)

  questionText  String               @db.Text
  options       String[]
  correctIndex  Int
  orderIndex    Int
  status        TriviaQuestionStatus @default(PENDING)

  answers       TriviaAnswer[]

  @@index([gameId, orderIndex])
  @@map("trivia_questions")
}

model TriviaAnswer {
  id              String         @id @default(cuid())
  createdAt       DateTime       @default(now())

  questionId      String
  question        TriviaQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  teamId          String
  team            Team           @relation(fields: [teamId], references: [id], onDelete: Cascade)

  submittedById   String
  submittedBy     UserReference  @relation(fields: [submittedById], references: [id])

  selectedIndex   Int
  isCorrect       Boolean
  responseTimeMs  Int

  @@unique([questionId, teamId])
  @@index([questionId])
  @@index([teamId])
  @@map("trivia_answers")
}

model TriviaTeamScore {
  id            String     @id @default(cuid())

  gameId        String
  game          TriviaGame @relation(fields: [gameId], references: [id], onDelete: Cascade)

  teamId        String
  team          Team       @relation(fields: [teamId], references: [id], onDelete: Cascade)

  totalScore    Int        @default(0)
  correctCount  Int        @default(0)
  speedBonuses  Int        @default(0)

  @@unique([gameId, teamId])
  @@index([gameId])
  @@map("trivia_team_scores")
}

// ==========================
// AI Agent Notifications
// ==========================

enum AgentNotificationType {
  ANOMALY_DETECTED
  INTERVENTION_EXECUTED
}

enum AgentNotificationSeverity {
  CRITICAL
  WARNING
  INFO
}

model AgentNotification {
  id          String                     @id @default(cuid())
  createdAt   DateTime                   @default(now())

  eventId     String
  sessionId   String?

  type        AgentNotificationType
  severity    AgentNotificationSeverity  @default(INFO)

  // Type-specific data (anomaly_type, intervention_type, confidence, etc.)
  data        Json

  readBy      AgentNotificationRead[]

  @@index([eventId])
  @@index([eventId, createdAt(sort: Desc)])
  @@map("agent_notifications")
}

model AgentNotificationRead {
  userId         String
  notificationId String
  notification   AgentNotification @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  readAt         DateTime          @default(now())

  @@id([userId, notificationId])
  @@map("agent_notification_reads")
}