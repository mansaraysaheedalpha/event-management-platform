
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum IncidentType {
  HARASSMENT
  MEDICAL
  TECHNICAL
  SECURITY
  ACCESSIBILITY
}

enum IncidentStatus {
  REPORTED
  ACKNOWLEDGED
  INVESTIGATING
  RESOLVED
}

enum IncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

// Add this new enum
enum PointReason {
  MESSAGE_SENT
  MESSAGE_REACTED
  QUESTION_ASKED
  QUESTION_UPVOTED
  POLL_CREATED
  POLL_VOTED
  WAITLIST_JOINED
}

model SyncLog {
  id        String   @id @default(cuid())
  timestamp DateTime @default(now())

  // The user this change is relevant for
  userId    String
  user      UserReference @relation(fields: [userId], references: [id])
  
  resource  String // e.g., 'MESSAGE', 'POLL'
  action    String // e.g., 'CREATED', 'UPDATED'
  payload   Json   // The actual data payload

  @@index([userId, timestamp])
  @@map("sync_logs")
}

model UserReference {
  id                        String @id
  email                     String @unique
  firstName                 String?
  lastName                  String?

  messages                  Message[]
  questions                 Question[]
  questionUpvotes           QuestionUpvote[]
  createdPolls              Poll[]
  pollVotes                 PollVote[]
  // This now correctly points to the Conversation model
  conversations             Conversation[]
  sentDirectMessages        DirectMessage[]  @relation("SentMessages")
  reportedIncidents         Incident[]
  assignedIncidents         Incident[] @relation("AssignedIncidents")
  syncLogs                  SyncLog[]
  answers                   Answer[]
  messageReactions          MessageReaction[]
  gamificationPointEntries  GamificationPointEntry[]
  gamificationAchievements  GamificationAchievement[]
  createdCircles            ConversationCircle[]
  circleMemberships         ConversationCircleParticipant[]
  @@map("user_references")
}

model Conversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // This now correctly points to the UserReference model
  participants UserReference[]
  messages     DirectMessage[]

  @@map("conversations")
}

// NOTE: The incorrect '_ConversationParticipants' model has been completely removed.
// Prisma will now generate the required join table in the background.

model ChatSession {
  id           String @id @default(cuid())
  name         String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  participants String[]
  eventId        String
  organizationId String
  messages     Message[]
  questions    Question[]
  polls        Poll[]
  presentation Presentation? // Add the one-to-one relation
  incidents    Incident[]
  gamificationPointEntries GamificationPointEntry[]
  conversationCircles ConversationCircle[]
  @@map("chat_sessions")
}

// Add the new Incident model
model Incident {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  type      IncidentType
  severity  IncidentSeverity
  status    IncidentStatus @default(REPORTED)
  details   String         @db.Text

  reporterId String
  reporter   UserReference @relation(fields: [reporterId], references: [id])
  
  // To associate with the event and org
  organizationId String
  eventId        String
  sessionId      String
  session        ChatSession   @relation(fields: [sessionId], references: [id])

  // To track which admin is handling the incident
  assigneeId String?
  assignee   UserReference? @relation("AssignedIncidents", fields: [assigneeId], references: [id])

  resolutionNotes String?

  @@map("incidents")
}

//client keeps asking server for updates every 5 seconds: feature to be worked on

model Message {
  id        String   @id @default(cuid())
  text      String
  timestamp DateTime @default(now())
  metadata  Json?
  authorId  String
  author    UserReference @relation(fields: [authorId], references: [id], onDelete: Cascade)
  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  reactions MessageReaction[]
  @@index([sessionId, timestamp])
  @@map("messages")
}

model DirectMessage {
  id             String   @id @default(cuid())
  text           String   @db.Text
  timestamp      DateTime @default(now())
  isDelivered    Boolean  @default(false)
  deliveredAt    DateTime?
  isRead         Boolean  @default(false)
  readAt         DateTime?
  senderId       String
  sender         UserReference @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  conversationId String
  conversation   Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  @@map("direct_messages")
}

model Answer {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  text      String   @db.Text

  authorId String
  author   UserReference @relation(fields: [authorId], references: [id], onDelete: Cascade)

  questionId String    @unique // Enforces a one-to-one relationship
  question   Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@map("answers")
}

model Question {
  id          String   @id @default(cuid())
  text        String   @db.VarChar(500)
  isAnonymous Boolean  @default(false)
  status      String   @default("pending")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  authorId    String
  author      UserReference @relation(fields: [authorId], references: [id], onDelete: Cascade)
  sessionId   String
  session     ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  upvotes     QuestionUpvote[]
  answer      Answer?
  @@map("questions")
}

model QuestionUpvote {
  userId     String
  user       UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  questionId String
  question   Question      @relation(fields: [questionId], references: [id], onDelete: Cascade)
  createdAt  DateTime      @default(now())
  @@id([userId, questionId])
  @@map("question_upvotes")
}

// Add this new model
model MessageReaction {
  id        String   @id @default(cuid())
  emoji     String
  createdAt DateTime @default(now())

  userId    String
  user      UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  messageId String
  message   Message       @relation(fields: [messageId], references: [id], onDelete: Cascade)

  // Enforces that a user can only react with the same emoji once per message
  @@unique([userId, messageId, emoji])
  @@map("message_reactions")
}

model Poll {
  id        String   @id @default(cuid())
  question  String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  expiresAt DateTime?
  creatorId String
  creator   UserReference @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  options   PollOption[]
  votes     PollVote[]
  @@map("polls")
}

model PollOption {
  id     String     @id @default(cuid())
  text   String
  pollId String
  poll   Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  votes  PollVote[]
  @@map("poll_options")
}

model PollVote {
  userId   String
  user     UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  pollId   String
  poll     Poll          @relation(fields: [pollId], references: [id], onDelete: Cascade)
  optionId String
  option   PollOption    @relation(fields: [optionId], references: [id], onDelete: Cascade)
  createdAt DateTime   @default(now())
  @@id([userId, pollId])
  @@map("poll_votes")
}

model Presentation {
  id        String   @id @default(cuid())
  sessionId String   @unique // Each session has one presentation
  session   ChatSession @relation(fields: [sessionId], references: [id])
  
  // This will store the ordered list of URLs from S3/CDN
  slideUrls String[]

  @@map("presentations")
}

model GamificationPointEntry {
  id        String     @id @default(cuid())
  createdAt DateTime   @default(now())
  points    Int
  reason    PointReason

  userId    String
  user      UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)

  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([userId, sessionId, reason])
  @@index([userId, sessionId])
  @@map("gamification_point_entries")
}

model GamificationAchievement {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  badgeName   String   // e.g., "First Question", "Super Voter"
  description String

  userId      String
  user        UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeName])
  @@map("gamification_achievements")
}

model ConversationCircle {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  topic     String   @db.VarChar(255)
  isActive  Boolean  @default(true)

  creatorId String
  creator   UserReference @relation(fields: [creatorId], references: [id])
  
  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id])
  
  participants ConversationCircleParticipant[]

  @@map("conversation_circles")
}


model ConversationCircleParticipant {
  joinedAt DateTime @default(now())

  userId   String
  user     UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  circleId String
  circle   ConversationCircle @relation(fields: [circleId], references: [id], onDelete: Cascade)
  
  @@id([userId, circleId])
  @@map("conversation_circle_participants")
}