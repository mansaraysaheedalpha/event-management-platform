
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum IncidentType {
  HARASSMENT
  MEDICAL
  TECHNICAL
  SECURITY
  ACCESSIBILITY
}

enum IncidentStatus {
  REPORTED
  ACKNOWLEDGED
  INVESTIGATING
  RESOLVED
}

enum IncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

// Add this new enum
enum PointReason {
  MESSAGE_SENT
  MESSAGE_REACTED
  QUESTION_ASKED
  QUESTION_UPVOTED
  POLL_CREATED
  POLL_VOTED
  WAITLIST_JOINED
}

model SyncLog {
  id        String   @id @default(cuid())
  timestamp DateTime @default(now())

  // The user this change is relevant for
  userId    String
  user      UserReference @relation(fields: [userId], references: [id])
  
  resource  String // e.g., 'MESSAGE', 'POLL'
  action    String // e.g., 'CREATED', 'UPDATED'
  payload   Json   // The actual data payload

  @@index([userId, timestamp])
  @@map("sync_logs")
}

model UserReference {
  id                        String @id
  email                     String @unique
  firstName                 String?
  lastName                  String?

  messages                  Message[]
  questions                 Question[]
  questionUpvotes           QuestionUpvote[]
  createdPolls              Poll[]
  pollVotes                 PollVote[]
  // This now correctly points to the Conversation model
  conversations             Conversation[]
  sentDirectMessages        DirectMessage[]  @relation("SentMessages")
  reportedIncidents         Incident[]
  assignedIncidents         Incident[] @relation("AssignedIncidents")
  syncLogs                  SyncLog[]
  answers                   Answer[]
  messageReactions          MessageReaction[]
  gamificationPointEntries  GamificationPointEntry[]
  gamificationAchievements  GamificationAchievement[]
  createdCircles            ConversationCircle[]
  circleMemberships         ConversationCircleParticipant[]
  sentBackchannelMessages   BackchannelMessage[]
  createdTeams              Team[]
  teamMemberships           TeamMembership[]
  contentDrops              ContentDropLog[]
  @@map("user_references")
}

model Conversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // This now correctly points to the UserReference model
  participants UserReference[]
  messages     DirectMessage[]

  @@map("conversations")
}

// NOTE: The incorrect '_ConversationParticipants' model has been completely removed.
// Prisma will now generate the required join table in the background.

model ChatSession {
  id                          String @id @default(cuid())
  name                        String
  createdAt                   DateTime @default(now())
  updatedAt                   DateTime @updatedAt
  participants                String[]
  eventId                     String
  organizationId              String
  messages                    Message[]
  questions                   Question[]
  polls                       Poll[]
  presentation                Presentation? // Add the one-to-one relation
  incidents                   Incident[]
  gamificationPointEntries    GamificationPointEntry[]
  conversationCircles         ConversationCircle[]
  backchannelMessages         BackchannelMessage[]
  teams                       Team[]
  contentDrops                ContentDropLog[]
  giveawayWinners             GiveawayWinner[]
  quizSettings                SessionQuizSettings?
  @@map("chat_sessions")
}

// Add the new Incident model
model Incident {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  type      IncidentType
  severity  IncidentSeverity
  status    IncidentStatus @default(REPORTED)
  details   String         @db.Text

  reporterId String
  reporter   UserReference @relation(fields: [reporterId], references: [id])
  
  // To associate with the event and org
  organizationId String
  eventId        String
  sessionId      String
  session        ChatSession   @relation(fields: [sessionId], references: [id])

  // To track which admin is handling the incident
  assigneeId String?
  assignee   UserReference? @relation("AssignedIncidents", fields: [assigneeId], references: [id])

  resolutionNotes String?

  @@map("incidents")
}

//client keeps asking server for updates every 5 seconds: feature to be worked on

model Message {
  id        String   @id @default(cuid())
  text      String
  timestamp DateTime @default(now())
  metadata  Json?
  authorId  String
  author    UserReference @relation(fields: [authorId], references: [id], onDelete: Cascade)
  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  // --- ADD THESE FIELDS FOR THREADING ---
  replyingToMessageId String?
  parentMessage       Message?  @relation("Replies", fields: [replyingToMessageId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies             Message[] @relation("Replies")
  // --- END OF NEW FIELDS ---
  reactions MessageReaction[]
   
  @@index([sessionId, timestamp])
  @@map("messages")
}

model DirectMessage {
  id             String   @id @default(cuid())
  text           String   @db.Text
  timestamp      DateTime @default(now())
  isDelivered    Boolean  @default(false)
  deliveredAt    DateTime?
  isRead         Boolean  @default(false)
  readAt         DateTime?
  isEdited       Boolean  @default(false) 
  editedAt       DateTime?  
  metadata      Json?      @default("{}")  
  senderId       String
  sender         UserReference @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  conversationId String
  conversation   Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  @@map("direct_messages")
}

model Answer {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  text      String   @db.Text

  authorId String
  author   UserReference @relation(fields: [authorId], references: [id], onDelete: Cascade)

  questionId String    @unique // Enforces a one-to-one relationship
  question   Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@map("answers")
}

model Question {
  id          String   @id @default(cuid())
  text        String   @db.VarChar(500)
  isAnonymous Boolean  @default(false)
  status      String   @default("pending")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  authorId    String
  author      UserReference @relation(fields: [authorId], references: [id], onDelete: Cascade)
  sessionId   String
  session     ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  isAnswered  Boolean  @default(false)
  upvotes     QuestionUpvote[]
  answer      Answer?
    
  tags        String[]
  @@map("questions")
}

model QuestionUpvote {
  userId     String
  user       UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  questionId String
  question   Question      @relation(fields: [questionId], references: [id], onDelete: Cascade)
  createdAt  DateTime      @default(now())
  @@id([userId, questionId])
  @@map("question_upvotes")
}

// Add this new model
model MessageReaction {
  id        String   @id @default(cuid())
  emoji     String
  createdAt DateTime @default(now())

  userId    String
  user      UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  messageId String
  message   Message       @relation(fields: [messageId], references: [id], onDelete: Cascade)

  // Enforces that a user can only react with the same emoji once per message
  @@unique([userId, messageId, emoji])
  @@map("message_reactions")
}

model Poll {
  id              String   @id @default(cuid())
  question        String
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  expiresAt       DateTime?
  creatorId       String
  creator         UserReference @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  sessionId       String
  session         ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  options         PollOption[]
  votes           PollVote[]
  giveawayWinners GiveawayWinner[]

  // Quiz/Giveaway fields
  correctOptionId String?     // For quiz mode - the correct answer
  isQuiz          Boolean  @default(false)  // Whether this poll is part of a quiz
  giveawayEnabled Boolean  @default(false)  // Whether giveaway can be run on this poll

  @@map("polls")
}

model PollOption {
  id     String     @id @default(cuid())
  text   String
  pollId String
  poll   Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  votes  PollVote[]
  @@map("poll_options")
}

model PollVote {
  userId   String
  user     UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  pollId   String
  poll     Poll          @relation(fields: [pollId], references: [id], onDelete: Cascade)
  optionId String
  option   PollOption    @relation(fields: [optionId], references: [id], onDelete: Cascade)
  createdAt DateTime   @default(now())
  @@id([userId, pollId])
  @@map("poll_votes")
}

enum GiveawayType {
  SINGLE_POLL
  QUIZ_SCORE
}

enum ClaimStatus {
  PENDING
  CLAIMED
  EXPIRED
}

model GiveawayWinner {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Context
  sessionId String
  session   ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  eventId   String
  pollId    String?     // NULL for quiz giveaways
  poll      Poll?       @relation(fields: [pollId], references: [id], onDelete: SetNull)

  // Winner Identity
  userId      String
  winnerName  String
  winnerEmail String

  // Giveaway Details
  giveawayType      GiveawayType
  winningOptionText String?       // For single poll
  quizScore         Int?          // For quiz (e.g., 4 out of 5)
  quizTotal         Int?          // Total quiz questions

  // Prize Details
  prizeTitle       String?
  prizeDescription String?
  prizeType        String?       // 'physical' | 'virtual' | 'voucher'
  prizeValue       Decimal?      @db.Decimal(10, 2)

  // Claim Information
  claimInstructions String?
  claimLocation     String?       // For physical prizes
  claimDeadline     DateTime?
  claimedAt         DateTime?
  claimStatus       ClaimStatus   @default(PENDING)

  // Notification Status
  emailSent     Boolean   @default(false)
  emailSentAt   DateTime?
  notificationError String?

  // Who ran the giveaway
  createdById   String?

  @@index([sessionId])
  @@index([eventId])
  @@index([userId])
  @@map("giveaway_winners")
}

model SessionQuizSettings {
  id        String   @id @default(cuid())
  sessionId String   @unique
  session   ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Quiz Configuration
  quizEnabled    Boolean @default(false)
  passingScore   Int     @default(3)      // Minimum correct answers to win
  totalQuestions Int?                      // Auto-calculated from polls

  // Prize Configuration
  prizeTitle         String?
  prizeDescription   String?
  prizeType          String?   @default("virtual")
  prizeValue         Decimal?  @db.Decimal(10, 2)
  claimInstructions  String?
  claimLocation      String?
  claimDeadlineHours Int       @default(72)  // Hours after giveaway to claim

  // Limits
  maxWinners Int?                          // NULL = unlimited

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("session_quiz_settings")
}

model Presentation {
  id        String   @id @default(cuid())
  sessionId String   @unique // Each session has one presentation
  session   ChatSession @relation(fields: [sessionId], references: [id])
  
  // This will store the ordered list of URLs from S3/CDN
  slideUrls String[]

  @@map("presentations")
}

model GamificationPointEntry {
  id        String     @id @default(cuid())
  createdAt DateTime   @default(now())
  points    Int
  reason    PointReason

  userId    String
  user      UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)

  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([userId, sessionId, reason])
  @@index([userId, sessionId])
  @@map("gamification_point_entries")
}

model GamificationAchievement {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  badgeName   String   // e.g., "First Question", "Super Voter"
  description String

  userId      String
  user        UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeName])
  @@map("gamification_achievements")
}

model ConversationCircle {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  topic     String   @db.VarChar(255)
  isActive  Boolean  @default(true)

  creatorId String
  creator   UserReference @relation(fields: [creatorId], references: [id])
  
  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id])
  
  participants ConversationCircleParticipant[]

  @@map("conversation_circles")
}


model ConversationCircleParticipant {
  joinedAt DateTime @default(now())

  userId   String
  user     UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  circleId String
  circle   ConversationCircle @relation(fields: [circleId], references: [id], onDelete: Cascade)
  
  @@id([userId, circleId])
  @@map("conversation_circle_participants")
}

model BackchannelMessage {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  text      String   @db.Text

  senderId  String
  sender    UserReference @relation(fields: [senderId], references: [id], onDelete: Cascade)

  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@map("backchannel_messages")
}

// Add these new models
model Team {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  name      String

  creatorId String
  creator   UserReference @relation(fields: [creatorId], references: [id])
  
  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id])
  
  members   TeamMembership[]

  @@unique([sessionId, name])
  @@map("teams")
}

model TeamMembership {
  joinedAt DateTime @default(now())

  userId String
  user   UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  teamId String
  team   Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  
  @@id([userId, teamId])
  @@map("team_memberships")
}

// Add this new model
model ContentDropLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  dropperId String
  dropper   UserReference @relation(fields: [dropperId], references: [id])
  
  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id])
  
  title       String
  description String?
  contentType String // e.g., 'DOCUMENT', 'LINK'
  contentUrl  String

  @@map("content_drop_logs")
}