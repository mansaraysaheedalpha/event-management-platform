
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum IncidentType {
  HARASSMENT
  MEDICAL
  TECHNICAL
  SECURITY
  ACCESSIBILITY
}

enum IncidentStatus {
  REPORTED
  ACKNOWLEDGED
  INVESTIGATING
  RESOLVED
}

enum IncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

// Add this new enum
enum PointReason {
  MESSAGE_SENT
  MESSAGE_REACTED
  QUESTION_ASKED
  QUESTION_UPVOTED
  POLL_CREATED
  POLL_VOTED
  WAITLIST_JOINED
}

// Connection tracking enums
enum ConnectionType {
  PROXIMITY_PING
  DM_INITIATED
  SESSION_QA
  MANUAL_EXCHANGE
}

enum OutcomeType {
  MEETING_HELD
  JOB_REFERRAL
  PARTNERSHIP
  SALE_DEAL
  MENTORSHIP
  OTHER
}

enum ContextType {
  SHARED_SESSION
  SHARED_INTEREST
  MUTUAL_CONNECTION
  SAME_COMPANY_SIZE
  SAME_INDUSTRY
  QA_INTERACTION
}

// Connection strength for relationship quality tracking
enum ConnectionStrength {
  WEAK          // Single interaction only
  MODERATE      // Multiple interactions OR follow-up exchanged
  STRONG        // Multiple follow-ups, meeting scheduled, or outcome reported
}

// Activity types for connection activity tracking
enum ConnectionActivityType {
  INITIAL_CONNECT   // First connection made
  DM_SENT           // Direct message sent
  DM_RECEIVED       // Direct message received
  HUDDLE_TOGETHER   // Attended same huddle
  FOLLOW_UP_SENT    // Post-event follow-up sent
  FOLLOW_UP_OPENED  // Follow-up was opened
  FOLLOW_UP_REPLIED // Follow-up was replied to
  MEETING_SCHEDULED // Meeting was scheduled
  MEETING_HELD      // Meeting actually happened
  OUTCOME_REPORTED  // Business outcome reported
  LINKEDIN_CONNECTED // Connected on LinkedIn
}

// Huddle (micro-meetup) enums
enum HuddleStatus {
  FORMING       // Invitations sent, waiting for responses
  CONFIRMED     // Minimum participants reached
  IN_PROGRESS   // Huddle is happening now
  COMPLETED     // Huddle finished successfully
  CANCELLED     // Huddle was cancelled
}

enum HuddleType {
  PROBLEM_BASED   // Based on shared problems/challenges
  SESSION_BASED   // Post-session discussion
  PROXIMITY_BASED // Impromptu based on location
  MANUAL          // User-created
}

enum HuddleParticipantStatus {
  INVITED   // Invitation sent
  ACCEPTED  // User accepted
  DECLINED  // User declined
  ATTENDED  // User actually showed up
  NO_SHOW   // Accepted but didn't attend
}

model SyncLog {
  id        String   @id @default(cuid())
  timestamp DateTime @default(now())

  // The user this change is relevant for
  userId    String
  user      UserReference @relation(fields: [userId], references: [id])
  
  resource  String // e.g., 'MESSAGE', 'POLL'
  action    String // e.g., 'CREATED', 'UPDATED'
  payload   Json   // The actual data payload

  @@index([userId, timestamp])
  @@map("sync_logs")
}

model UserReference {
  id                        String @id
  email                     String @unique
  firstName                 String?
  lastName                  String?
  avatarUrl                 String?

  // LinkedIn integration fields
  linkedInUrl               String?
  linkedInId                String?
  linkedInHeadline          String?
  linkedInAccessToken       String?
  linkedInRefreshToken      String?
  linkedInTokenExpiresAt    DateTime?

  messages                  Message[]
  questions                 Question[]
  questionUpvotes           QuestionUpvote[]
  createdPolls              Poll[]
  pollVotes                 PollVote[]
  // This now correctly points to the Conversation model
  conversations             Conversation[]
  sentDirectMessages        DirectMessage[]  @relation("SentMessages")
  reportedIncidents         Incident[]
  assignedIncidents         Incident[] @relation("AssignedIncidents")
  syncLogs                  SyncLog[]
  answers                   Answer[]
  messageReactions          MessageReaction[]
  gamificationPointEntries  GamificationPointEntry[]
  gamificationAchievements  GamificationAchievement[]
  createdCircles            ConversationCircle[]
  circleMemberships         ConversationCircleParticipant[]
  sentBackchannelMessages   BackchannelMessage[]
  createdTeams              Team[]
  teamMemberships           TeamMembership[]
  contentDrops              ContentDropLog[]
  connectionsAsUserA        Connection[] @relation("ConnectionUserA")
  connectionsAsUserB        Connection[] @relation("ConnectionUserB")

  // Breakout rooms
  createdBreakoutRooms      BreakoutRoom[]        @relation("BreakoutRoomCreator")
  facilitatedBreakoutRooms  BreakoutRoom[]        @relation("BreakoutRoomFacilitator")
  breakoutParticipations    BreakoutParticipant[]

  @@map("user_references")
}

model Conversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // This now correctly points to the UserReference model
  participants UserReference[]
  messages     DirectMessage[]

  @@map("conversations")
}

// NOTE: The incorrect '_ConversationParticipants' model has been completely removed.
// Prisma will now generate the required join table in the background.

model ChatSession {
  id                          String @id @default(cuid())
  name                        String
  createdAt                   DateTime @default(now())
  updatedAt                   DateTime @updatedAt
  participants                String[]
  eventId                     String
  organizationId              String
  messages                    Message[]
  questions                   Question[]
  polls                       Poll[]
  presentation                Presentation? // Add the one-to-one relation
  incidents                   Incident[]
  gamificationPointEntries    GamificationPointEntry[]
  conversationCircles         ConversationCircle[]
  backchannelMessages         BackchannelMessage[]
  teams                       Team[]
  contentDrops                ContentDropLog[]
  giveawayWinners             GiveawayWinner[]
  quizSettings                SessionQuizSettings?
  @@map("chat_sessions")
}

// Add the new Incident model
model Incident {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  type      IncidentType
  severity  IncidentSeverity
  status    IncidentStatus @default(REPORTED)
  details   String         @db.Text

  reporterId String
  reporter   UserReference @relation(fields: [reporterId], references: [id])
  
  // To associate with the event and org
  organizationId String
  eventId        String
  sessionId      String
  session        ChatSession   @relation(fields: [sessionId], references: [id])

  // To track which admin is handling the incident
  assigneeId String?
  assignee   UserReference? @relation("AssignedIncidents", fields: [assigneeId], references: [id])

  resolutionNotes String?

  @@map("incidents")
}

//client keeps asking server for updates every 5 seconds: feature to be worked on

model Message {
  id        String   @id @default(cuid())
  text      String
  timestamp DateTime @default(now())
  metadata  Json?
  authorId  String
  author    UserReference @relation(fields: [authorId], references: [id], onDelete: Cascade)
  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  // --- ADD THESE FIELDS FOR THREADING ---
  replyingToMessageId String?
  parentMessage       Message?  @relation("Replies", fields: [replyingToMessageId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies             Message[] @relation("Replies")
  // --- END OF NEW FIELDS ---
  reactions MessageReaction[]
   
  @@index([sessionId, timestamp])
  @@map("messages")
}

model DirectMessage {
  id             String   @id @default(cuid())
  text           String   @db.Text
  timestamp      DateTime @default(now())
  isDelivered    Boolean  @default(false)
  deliveredAt    DateTime?
  isRead         Boolean  @default(false)
  readAt         DateTime?
  isEdited       Boolean  @default(false) 
  editedAt       DateTime?  
  metadata      Json?      @default("{}")  
  senderId       String
  sender         UserReference @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  conversationId String
  conversation   Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  @@map("direct_messages")
}

model Answer {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  text      String   @db.Text

  authorId String
  author   UserReference @relation(fields: [authorId], references: [id], onDelete: Cascade)

  questionId String    @unique // Enforces a one-to-one relationship
  question   Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@map("answers")
}

model Question {
  id          String   @id @default(cuid())
  text        String   @db.VarChar(500)
  isAnonymous Boolean  @default(false)
  status      String   @default("pending")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  authorId    String
  author      UserReference @relation(fields: [authorId], references: [id], onDelete: Cascade)
  sessionId   String
  session     ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  isAnswered  Boolean  @default(false)
  upvotes     QuestionUpvote[]
  answer      Answer?
    
  tags        String[]
  @@map("questions")
}

model QuestionUpvote {
  userId     String
  user       UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  questionId String
  question   Question      @relation(fields: [questionId], references: [id], onDelete: Cascade)
  createdAt  DateTime      @default(now())
  @@id([userId, questionId])
  @@map("question_upvotes")
}

// Add this new model
model MessageReaction {
  id        String   @id @default(cuid())
  emoji     String
  createdAt DateTime @default(now())

  userId    String
  user      UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  messageId String
  message   Message       @relation(fields: [messageId], references: [id], onDelete: Cascade)

  // Enforces that a user can only react with the same emoji once per message
  @@unique([userId, messageId, emoji])
  @@map("message_reactions")
}

model Poll {
  id              String   @id @default(cuid())
  question        String
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  expiresAt       DateTime?
  creatorId       String
  creator         UserReference @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  sessionId       String
  session         ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  options         PollOption[]
  votes           PollVote[]
  giveawayWinners GiveawayWinner[]

  // Quiz/Giveaway fields
  correctOptionId String?     // For quiz mode - the correct answer
  isQuiz          Boolean  @default(false)  // Whether this poll is part of a quiz
  giveawayEnabled Boolean  @default(false)  // Whether giveaway can be run on this poll

  @@map("polls")
}

model PollOption {
  id     String     @id @default(cuid())
  text   String
  pollId String
  poll   Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  votes  PollVote[]
  @@map("poll_options")
}

model PollVote {
  userId   String
  user     UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  pollId   String
  poll     Poll          @relation(fields: [pollId], references: [id], onDelete: Cascade)
  optionId String
  option   PollOption    @relation(fields: [optionId], references: [id], onDelete: Cascade)
  createdAt DateTime   @default(now())
  @@id([userId, pollId])
  @@map("poll_votes")
}

enum GiveawayType {
  SINGLE_POLL
  QUIZ_SCORE
}

enum ClaimStatus {
  PENDING
  CLAIMED
  EXPIRED
}

model GiveawayWinner {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Context
  sessionId String
  session   ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  eventId   String
  pollId    String?     // NULL for quiz giveaways
  poll      Poll?       @relation(fields: [pollId], references: [id], onDelete: SetNull)

  // Winner Identity
  userId      String
  winnerName  String
  winnerEmail String

  // Giveaway Details
  giveawayType      GiveawayType
  winningOptionText String?       // For single poll
  quizScore         Int?          // For quiz (e.g., 4 out of 5)
  quizTotal         Int?          // Total quiz questions

  // Prize Details
  prizeTitle       String?
  prizeDescription String?
  prizeType        String?       // 'physical' | 'virtual' | 'voucher'
  prizeValue       Decimal?      @db.Decimal(10, 2)

  // Claim Information
  claimInstructions String?
  claimLocation     String?       // For physical prizes
  claimDeadline     DateTime?
  claimedAt         DateTime?
  claimStatus       ClaimStatus   @default(PENDING)

  // Notification Status
  emailSent     Boolean   @default(false)
  emailSentAt   DateTime?
  notificationError String?

  // Who ran the giveaway
  createdById   String?

  @@index([sessionId])
  @@index([eventId])
  @@index([userId])
  @@map("giveaway_winners")
}

model SessionQuizSettings {
  id        String   @id @default(cuid())
  sessionId String   @unique
  session   ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Quiz Configuration
  quizEnabled    Boolean @default(false)
  passingScore   Int     @default(3)      // Minimum correct answers to win
  totalQuestions Int?                      // Auto-calculated from polls

  // Prize Configuration
  prizeTitle         String?
  prizeDescription   String?
  prizeType          String?   @default("virtual")
  prizeValue         Decimal?  @db.Decimal(10, 2)
  claimInstructions  String?
  claimLocation      String?
  claimDeadlineHours Int       @default(72)  // Hours after giveaway to claim

  // Limits
  maxWinners Int?                          // NULL = unlimited

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("session_quiz_settings")
}

model Presentation {
  id        String   @id @default(cuid())
  sessionId String   @unique // Each session has one presentation
  session   ChatSession @relation(fields: [sessionId], references: [id])
  
  // This will store the ordered list of URLs from S3/CDN
  slideUrls String[]

  @@map("presentations")
}

model GamificationPointEntry {
  id        String     @id @default(cuid())
  createdAt DateTime   @default(now())
  points    Int
  reason    PointReason

  userId    String
  user      UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)

  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([userId, sessionId, reason])
  @@index([userId, sessionId])
  @@map("gamification_point_entries")
}

model GamificationAchievement {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  badgeName   String   // e.g., "First Question", "Super Voter"
  description String

  userId      String
  user        UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeName])
  @@map("gamification_achievements")
}

model ConversationCircle {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  topic     String   @db.VarChar(255)
  isActive  Boolean  @default(true)

  creatorId String
  creator   UserReference @relation(fields: [creatorId], references: [id])
  
  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id])
  
  participants ConversationCircleParticipant[]

  @@map("conversation_circles")
}


model ConversationCircleParticipant {
  joinedAt DateTime @default(now())

  userId   String
  user     UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  circleId String
  circle   ConversationCircle @relation(fields: [circleId], references: [id], onDelete: Cascade)
  
  @@id([userId, circleId])
  @@map("conversation_circle_participants")
}

model BackchannelMessage {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  text      String   @db.Text

  senderId  String
  sender    UserReference @relation(fields: [senderId], references: [id], onDelete: Cascade)

  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@map("backchannel_messages")
}

// Add these new models
model Team {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  name      String

  creatorId String
  creator   UserReference @relation(fields: [creatorId], references: [id])
  
  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id])
  
  members   TeamMembership[]

  @@unique([sessionId, name])
  @@map("teams")
}

model TeamMembership {
  joinedAt DateTime @default(now())

  userId String
  user   UserReference @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  teamId String
  team   Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  
  @@id([userId, teamId])
  @@map("team_memberships")
}

// Add this new model
model ContentDropLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  dropperId String
  dropper   UserReference @relation(fields: [dropperId], references: [id])

  sessionId String
  session   ChatSession   @relation(fields: [sessionId], references: [id])

  title       String
  description String?
  contentType String // e.g., 'DOCUMENT', 'LINK'
  contentUrl  String

  @@map("content_drop_logs")
}

// Connection tracking models for networking feature
model Connection {
  id            String    @id @default(cuid())
  userAId       String
  userBId       String
  eventId       String

  // Connection metadata
  connectedAt   DateTime  @default(now())
  connectionType ConnectionType @default(PROXIMITY_PING)
  initialMessage String?

  // Connection strength (calculated based on activities)
  strength      ConnectionStrength @default(WEAK)
  lastInteractionAt DateTime?
  interactionCount  Int @default(1)

  // Follow-up tracking
  followUpSentAt    DateTime?
  followUpOpenedAt  DateTime?
  followUpRepliedAt DateTime?
  followUpMessage   String?  @db.Text  // AI-generated follow-up suggestion

  // Outcome tracking
  meetingScheduled  Boolean @default(false)
  meetingDate       DateTime?
  outcomeType       OutcomeType?
  outcomeNotes      String?
  outcomeReportedAt DateTime?

  // Relations
  userA         UserReference @relation("ConnectionUserA", fields: [userAId], references: [id])
  userB         UserReference @relation("ConnectionUserB", fields: [userBId], references: [id])
  contexts      ConnectionContext[]
  activities    ConnectionActivity[]

  @@unique([userAId, userBId, eventId])
  @@index([userAId])
  @@index([userBId])
  @@index([eventId])
  @@index([strength])
  @@map("connections")
}

model ConnectionContext {
  id            String   @id @default(cuid())
  connectionId  String
  contextType   ContextType
  contextValue  String

  connection    Connection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@index([connectionId])
  @@map("connection_contexts")
}

// Activity log for connection interactions
model ConnectionActivity {
  id            String   @id @default(cuid())
  connectionId  String
  createdAt     DateTime @default(now())

  // Activity details
  activityType  ConnectionActivityType
  description   String?  @db.Text
  metadata      Json?    // Additional context (e.g., message ID, huddle ID)

  // Who initiated this activity (optional, for directional activities)
  initiatorId   String?

  connection    Connection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@index([connectionId])
  @@index([createdAt])
  @@index([activityType])
  @@map("connection_activities")
}

// Huddle (micro-meetup) models for facilitated networking
model Huddle {
  id               String       @id @default(cuid())
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  // Huddle details
  topic            String       @db.VarChar(100)
  problemStatement String?      @db.Text
  description      String?      @db.Text

  // Event context
  eventId          String
  sessionId        String?      // Optional: if huddle is post-session

  // Location and timing
  locationName     String?      @db.VarChar(255)
  locationDetails  String?      @db.Text  // Room number, directions, etc.
  scheduledAt      DateTime
  duration         Int          @default(15)  // Duration in minutes

  // Status and type
  status           HuddleStatus @default(FORMING)
  huddleType       HuddleType   @default(PROBLEM_BASED)

  // Participant limits
  minParticipants  Int          @default(2)
  maxParticipants  Int          @default(6)

  // Optimistic locking for race condition handling
  version          Int          @default(1)

  // Creator (the system or user who initiated)
  createdById      String?

  // Relations
  participants     HuddleParticipant[]

  @@index([eventId])
  @@index([status])
  @@index([scheduledAt])
  @@map("huddles")
}

model HuddleParticipant {
  id          String   @id @default(cuid())
  huddleId    String
  userId      String

  // Status tracking
  status      HuddleParticipantStatus @default(INVITED)
  invitedAt   DateTime @default(now())
  respondedAt DateTime?
  attendedAt  DateTime?

  // Match score (why this user was invited)
  matchScore  Float?
  matchReason String?  @db.Text  // JSON or text explaining why they were matched

  // Relation
  huddle      Huddle   @relation(fields: [huddleId], references: [id], onDelete: Cascade)

  @@unique([huddleId, userId])
  @@index([userId])
  @@index([huddleId, status])
  @@map("huddle_participants")
}

// ==========================
// AI Matchmaking Models
// ==========================

// User networking profile for AI matchmaking
model UserProfile {
  id                String   @id @default(cuid())
  userId            String   @unique

  // From registration (required)
  interests         String[]
  goals             Goal[]

  // From registration (optional)
  bio               String?  @db.Text
  industry          String?
  companySize       CompanySize?
  yearsExperience   Int?
  skillsToOffer     String[]
  skillsNeeded      String[]

  // From enrichment agent (auto-populated)
  enrichmentStatus  EnrichmentStatus @default(PENDING)
  enrichedAt        DateTime?

  // Professional platforms
  linkedInHeadline  String?
  linkedInUrl       String?
  githubUsername    String?
  githubTopLanguages String[]
  githubRepoCount   Int?
  twitterHandle     String?
  twitterBio        String?

  // Content/Social platforms
  youtubeChannelUrl String?
  youtubeChannelName String?
  youtubeSubscriberRange String?
  instagramHandle   String?
  instagramBio      String?
  facebookProfileUrl String?

  // General
  personalWebsite   String?
  extractedSkills   String[]
  extractedInterests String[]
  enrichmentSources String[]

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([userId])
  @@map("user_profiles")
}

// AI-generated matchmaking recommendations
model Recommendation {
  id                  String   @id @default(cuid())
  userId              String
  eventId             String
  recommendedUserId   String

  // LLM-generated content
  matchScore          Int      // 0-100
  reasons             String[]
  conversationStarters String[]
  potentialValue      String?

  // Metadata
  generatedAt         DateTime @default(now())
  expiresAt           DateTime

  // Tracking
  viewed              Boolean  @default(false)
  viewedAt            DateTime?
  pinged              Boolean  @default(false)
  pingedAt            DateTime?
  connected           Boolean  @default(false)
  connectedAt         DateTime?

  @@unique([userId, eventId, recommendedUserId])
  @@index([userId, eventId])
  @@index([eventId, expiresAt])
  @@map("recommendations")
}

// Feedback on connections for ML learning
model ConnectionFeedback {
  id              String   @id @default(cuid())
  connectionId    String
  userId          String   // Who is giving feedback

  // Rating
  rating          Int      // 1-5 stars

  // Qualitative
  wasValuable     Boolean?
  willFollowUp    Boolean?
  wouldRecommend  Boolean?

  // What made it good/bad
  positiveFactors String[]
  negativeFactors String[]

  // Free text
  comments        String?  @db.Text

  createdAt       DateTime @default(now())

  @@unique([connectionId, userId])
  @@index([connectionId])
  @@map("connection_feedback")
}

// Feedback on specific recommendations
model RecommendationFeedback {
  id                String   @id @default(cuid())
  recommendationId  String
  userId            String

  // Did they act on it?
  action            RecommendationAction

  // If they connected, how was it?
  connectionRating  Int?     // 1-5

  // Why did they skip?
  skipReason        String?

  createdAt         DateTime @default(now())

  @@unique([recommendationId, userId])
  @@index([recommendationId])
  @@map("recommendation_feedback")
}

enum Goal {
  LEARN
  NETWORK
  HIRE
  GET_HIRED
  FIND_PARTNERS
  FIND_INVESTORS
  SELL
  BUY
  MENTOR
  GET_MENTORED
}

enum CompanySize {
  SOLO
  STARTUP_1_10
  SMALL_11_50
  MEDIUM_51_200
  LARGE_201_1000
  ENTERPRISE_1000_PLUS
}

enum EnrichmentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  OPTED_OUT
}

enum RecommendationAction {
  VIEWED
  PINGED
  MESSAGED
  CONNECTED
  SKIPPED
  IGNORED
}

// ==========================
// Breakout Room Enums
// ==========================

enum BreakoutRoomStatus {
  WAITING    // Room created, waiting to start
  ACTIVE     // Room is live
  CLOSING    // Warning sent, about to close
  CLOSED     // Room ended
}

enum BreakoutParticipantRole {
  FACILITATOR
  PARTICIPANT
}

// ==========================
// Breakout Room Models
// ==========================

model BreakoutRoom {
  id                String              @id @default(cuid())
  createdAt         DateTime            @default(now())

  sessionId         String              // Parent session ID (from event-lifecycle-service)
  eventId           String              // Event ID for easier querying

  name              String              @db.VarChar(100)
  topic             String?             @db.VarChar(500)
  maxParticipants   Int                 @default(8)
  durationMinutes   Int                 @default(15)
  autoAssign        Boolean             @default(false)

  status            BreakoutRoomStatus  @default(WAITING)
  startedAt         DateTime?
  endedAt           DateTime?

  creatorId         String
  creator           UserReference       @relation("BreakoutRoomCreator", fields: [creatorId], references: [id])

  facilitatorId     String?
  facilitator       UserReference?      @relation("BreakoutRoomFacilitator", fields: [facilitatorId], references: [id])

  participants      BreakoutParticipant[]

  // Video room integration (external provider like Daily.co, Twilio, etc.)
  videoRoomId       String?             @db.VarChar(255)
  videoRoomUrl      String?             @db.VarChar(500)

  @@index([sessionId])
  @@index([eventId])
  @@index([status])
  @@map("breakout_rooms")
}

model BreakoutParticipant {
  id                    String                    @id @default(cuid())
  joinedAt              DateTime                  @default(now())
  leftAt                DateTime?

  role                  BreakoutParticipantRole   @default(PARTICIPANT)
  speakingTimeSeconds   Int                       @default(0)

  userId                String
  user                  UserReference             @relation(fields: [userId], references: [id], onDelete: Cascade)

  roomId                String
  room                  BreakoutRoom              @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@unique([userId, roomId])
  @@index([roomId])
  @@map("breakout_participants")
}